#!/usr/bin/perl
# Copyright 2016 Google Inc. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

use strict;
use utf8;
use warnings;

use FindBin;
use Term::ReadKey;

binmode STDERR, ':utf8';
binmode STDOUT, ':utf8';

my $max_pri = 5;
my $lang = $ENV{HORENSO_LANG} // 'jpn';
my $stats_mode = !!$ENV{HORENSO_STATS};

my %rad_to_key = (
    一 => 'a',
    丿 => 'a',
    二 => 'a',
    亠 => 'a',
    𠆢 => 'b',
    人 => 'b',
    亻 => 'b',
    儿 => 'c',
    入 => 'c',
    八 => 'c',
    冂 => 'c',
    冖 => 'c',
    冫 => 'c',
    几 => 'c',
    刀 => 'c',
    力 => 'c',
    匚 => 'c',
    十 => 'c',
    卜 => 'c',
    卩 => 'd',
    厂 => 'd',
    厶 => 'd',
    口 => 'd',
    囗 => 'e',
    土 => 'e',
    士 => 'e',
    夊 => 'e',
    夕 => 'e',
    大 => 'e',
    女 => 'f',
    小 => 'f',
    宀 => 'f',
    山 => 'g',
    巛 => 'g',
    工 => 'g',
    己 => 'g',
    巾 => 'g',
    幺 => 'g',
    广 => 'g',
    彑 => 'h',
    彳 => 'h',
    心 => 'h',
    忄 => 'h',
    㣺 => 'h',
    戈 => 'i',
    戸 => 'i',
    手 => 'i',
    扌 => 'i',
    攵 => 'j',
    攴 => 'j',
    文 => 'j',
    斗 => 'j',
    旡 => 'j',
    日 => 'j',
    曰 => 'j',
    月 => 'j',
    木 => 'k',
    欠 => 'l',
    止 => 'l',
    殳 => 'l',
    氵 => 'm',
    水 => 'm',
    氺 => 'm',
    火 => 'n',
    灬 => 'n',
    爪 => 'n',
    父 => 'n',
    爻 => 'n',
    犬 => 'n',
    玄 => 'n',
    玉 => 'o',
    田 => 'o',
    疋 => 'o',
    𤴔 => 'o',
    疒 => 'o',
    白 => 'p',
    皮 => 'p',
    皿 => 'p',
    目 => 'p',
    矛 => 'p',
    矢 => 'p',
    石 => 'p',
    禾 => 'q',
    穴 => 'q',
    立 => 'q',
    缶 => 's',
    羊 => 's',
    飛 => 't',
    耳 => 't',
    肉 => 't',
    臣 => 't',
    臼 => 't',
    舌 => 't',
    艹 => 'u',
    虍 => 'v',
    言 => 'w',
    豆 => 'w',
    豕 => 'w',
    豸 => 'x',
    貝 => 'x',
    足 => 'x',
    𧾷 => 'x',
    身 => 'x',
    辶 => 'y',
    邑 => 'y',
    酉 => 'y',
    里 => 'y',
    門 => ';',
    阜 => ';',
    隹 => ';',
    雨 => ';',
    韭 => ';',
    音 => ';',
    頁 => ',',
    食 => ',',
    骨 => ',',
    鬥 => ',',
    鬯 => '.',
    魚 => '.',
    鳥 => '.',
    鹵 => '.',
    黑 => '/',
    龜 => '/',
    龠 => '/',
    歯 => '/',
    齒 => '/',
);

my @yomiken = (
    'b'..'d',
    'f'..'h',
    'j'..'n',
    'p'..'t',
    'v'..'z',
    ';',
    ',',
    '.',
    '/',
);

my @yomi_ranges = qw{ア エキ カイ カン キ キヨ ケ コ コク シ シヤ シヨ シン セキ ソウ タイ チヨ テン トク ハン フ ホ マ ラ ル};

@yomiken == @yomi_ranges or die;

# 2~3打鍵コードの文字列 => 実際に入力される文字・文字列
my %codes;
my %code_prefixes;
sub write_code {
    my ($key, $value) = @_;
    return 0 if defined($codes{$key});
    $codes{$key} = $value;
    $key =~ s/.$//;
    $code_prefixes{$key} = 1;
    return 1;
}

# 間違いやすい字の実際ではないけど調べ得るコードプレフィックス
# 例えば、合の部首は口《ｄ》けれど、人《ｂ》と思い込む可能性がある
# なので、上記の%codesマップにdkg->合と云うエントリーがあるのに対して
# %suggestionsに"bg"と云うキーがあって、配列リファレンスの値に
# "dkg -> 合 (部首＝口)"のような文字列が含まれている。
#
# 入力コードプレフィックス => 入力したいと思われる漢字などの配列
my %suggestions;

my @codes_files = @ARGV;
my @entered_text;
my @uncommitted;

my @kanji_keys = ('a'..'z', q{;}, q{,}, q{.}, q{/});

sub shift_last_char {
    my ($full_key) = @_;
    my @key = split q{}, $full_key;
    my $orig = $key[-1];
    $key[-1] =~ tr{!@#$%^&*()A-Z:<>?}{1-90a-z;,./};
    if ($orig eq $key[-1]) {
        $key[-1] =~ tr{1-90a-z;,./}{!@#$%^&*()A-Z:<>?};
    }
    return join q{}, @key;
}

sub term_copy {
    my $copy_tool = $ENV{COPY_TOOL};
    if (!$copy_tool) {
        return;
    }

    open my $tool_proc, '|-', $copy_tool
        or die "Cannot run '$copy_tool': $!";
    binmode $tool_proc, ':utf8';
    print $tool_proc @_;
}

sub clear_screen {
    print "\033[2J";
}

sub erase_to_eol {
    print "\033[K";
}

# 漢字の優先度マッピング
# 使用頻度と似た概念
#  $max_pri   - 最も高い優先度
#  $max_pri-1 - やや低い
#  $max_pri-2 - もっと低い
# など..
#  ..
#  マップに無い - この漢字を使わない
my %kanji_to_priority;
sub write_priority {
    my ($ji, $pri) = @_;
    if (($kanji_to_priority{$ji} // -1) < $pri) {
        $kanji_to_priority{$ji} = $pri;
    }
}

sub read_priority {
    my ($ji) = @_;
    return $kanji_to_priority{$ji} // -1;
}

{
    open my $priority, '<', "$FindBin::Bin/priority/$lang";
    binmode $priority, ':utf8';
    my $priority_level = $max_pri;
    while (my $line = <$priority>) {
        next if $line =~ m/^#/;
        chomp $line;
        for my $kanji (split q{}, $line) {
            write_priority $kanji, $priority_level;
        }
        $priority_level--;
    }
}

# ターミナル上の字の幅を返す
# 半角の場合：1
# 全角の場合：2
# 文字列の長さが2以上の場合、全文字合計の幅を返す
sub char_width {
    my ($s) = @_;
    my $total = 0;

    # 幅を持たない色のコードを消す
    $s =~ s/\e\[\d\dm//g;

    for my $char (split q{}, $s) {
        my $ord = ord $char;
        if ($ord <= 0xff) {
            $total += 1;
        } elsif ($ord >= 0xff01 && $ord <= 0xff60) {
            # 全角英数字
            $total += 2;
        } elsif ($ord >= 0xff61 && $ord <= 0xffdc) {
            # 半角カタカナ
            $total += 1;
        } elsif ($ord >= 0xf900 && $ord < 0xfb00) {
            # CJK Compatibility Ideographs
            $total += 2;
        } elsif ($ord >= 0x10000) {
            # surrogate pair (多分、漢字)
            $total += 2;
        } elsif ($ord >= 0x3000 && $ord <= 0x30fe) {
            # 平仮名／片仮名
            $total += 2;
        } elsif ($ord >= 0x3200 && $ord < 0xa000) {
            # Enclosed CJK Letters [3200, 3300)
            # CJK 互換             [3300, 3400)
            # "Rare" CJK           [3400, 4e00)
            # 漢字                 [4e00, 0xa000)
            $total += 2;
        } else {
            $total += 1;
        }
    }

    return $total;
}

my @pri_colors;
{
    # 色のコードとエスケープコードは
    # https://en.wikipedia.org/wiki/ANSI_escape_code
    # を参考に
    my $theme = $ENV{HORENSO_COLOR_THEME} // q{};
    @pri_colors =
        $theme eq q{bright_bg} ? ("\e[34m", "\e[31m", "\e[32m", "\e[33m") :
        $theme eq q{off}       ? (                                      ) :
        $theme eq q{}          ? ("\e[93m", "\e[96m", "\e[95m", "\e[91m") :
        die "Unknown value for HORENSO_COLOR_THEME: $theme";
}

sub guide_ji  {
    my ($key) = @_;
    my $raw_ji = $codes{$key};
    my $padding = q{ } x (2 - char_width $raw_ji);
    my $pri_color = $pri_colors[$max_pri - read_priority($raw_ji)] // q{};
    return "$pri_color$raw_ji\e[39m$padding";
}

if (!@codes_files) {
    my @dirs = ("$FindBin::Bin/code");

    while (@dirs) {
        my $path = pop @dirs;
        next if $path =~ m{/\.+$};
        if (-f $path) {
            push @codes_files, $path;
            next;
        }
        opendir my $dir_handle, $path or die "$!";
        push @dirs, map { "$path/$_" } readdir($dir_handle);
    }
}

sub simplify_yomi {
    my ($a) = @_;
    # 読み鍵を決定する際、ひら・カタを区別しないので、ひらがなをカタカナに変換
    # する
    $a =~ tr/ぁ-ゖ/ァ-ヶ/;
    $a =~ tr/ャュョ/ヤユヨ/;
    # 半濁音と濁音も無視するので、濁点を取り除く
    $a =~ tr{ガギグゲゴザジズゼゾダヂヅデドバビブベボパピプペポ}
            {カキクケコサシスセソタチツテトハヒフヘホハヒフヘホ};
    return $a;
}

sub read_codes {
    %codes = ();
    %code_prefixes = ();
    %suggestions = ();
    my %unassigned_by_priority;
    my %ji_set_by_priority;
    my $total_assigned;

    for my $codes_file (@codes_files) {
        open my $codes, $codes_file
            or die "Cannot open $codes_file: $!";
        binmode $codes, ':utf8';

        my $register = sub {
            my ($key, $value) = @_;

            my $priority = read_priority($value);

            if ($stats_mode && $priority >= 0) {
                $ji_set_by_priority{$priority}->{$value} = 1;
                if (length($key) > 3) {
                    # コードが３文字以上だと入力できないので、
                    # 未割り当てとして見なす
                    my $pri_array = $unassigned_by_priority{$priority} //= [];
                    push @$pri_array, $value;
                } else {
                    $total_assigned++;
                }
            }

            # コードが衝突する場合、自動的にコードを整理
            # 優先度の低い方をシフトコードに移す
            if (defined $codes{$key}) {
                die if length($key) != 3;
                my $shift_key = shift_last_char($key);
                die "$codes_file $key $shift_key"
                    if defined($codes{$shift_key});

                if (read_priority($value) > read_priority($codes{$key})) {
                    write_code($shift_key, $codes{$key});
                    delete $codes{$key};
                } else {
                    $key = $shift_key;
                }
            }

            write_code($key, $value) or die "Duplicate code: $key";
        };

        while (my $line = <$codes>) {
            chomp $line;

            my ($key, $value, @notes) = split m/\t/, $line;
            if (!defined $value) {
                print STDERR "Could not process code: $line\n";
                die;
            }

            my $notes_by_prefix = sub {
                my ($prefix) = @_;
                my @result_notes;
                for my $note (@notes) {
                    next if $note !~ m/^\Q$prefix\E/;
                    push @result_notes, substr($note, length($prefix));
                }
                return @result_notes;
            };

            if (length($key) <= 3 && $lang eq 'cht') {
                my $kantaiji_key = $key;
                $kantaiji_key =~ tr/a-zA-Z/A-Za-z/;
                for my $kantaiji ($notes_by_prefix->('ktj')) {
                    if (!$stats_mode) {
                        write_priority($kantaiji, read_priority($value) - 1);
                    }
                    die "$codes_file" if $kantaiji_key eq $key;
                    $register->($kantaiji_key, $kantaiji);
                }
            }
            if ($lang eq 'jpn') {
                for my $sjt ($notes_by_prefix->('sjt')) {
                    $register->($key, $sjt);
                }
            }
            $register->($key, $value);

            # hbかhyの注がある場合は%suggestionsのマップを拡張する

            # hyに相当する読み鍵を計算する
            my @hy_keys = map {
                # yomikenとyomi_rangesを使って読みから読み鍵の変換を行う
                my $yomi = simplify_yomi $_;
                my $match_id = $#yomi_ranges;
                for my $id (0..($#yomi_ranges-1)) {
                    if (($yomi_ranges[$id + 1] cmp $yomi) > 0) {
                        $match_id = $id;
                        last;
                    }
                }
                $yomiken[$match_id];
            } $notes_by_prefix->('hy');

            # hbに相当する部首鍵を計算する
            my @hb_keys = map {
                if (!$rad_to_key{$_}) {
                    print STDERR "radical not in \%rad_to_key: $_\n";
                    die;
                }
                $rad_to_key{$_};
            } $notes_by_prefix->('hb');

            # 実際の読み・部首は明記されている場合、サジェストに入れる
            my @code_source_notes;
            push @code_source_notes, map { "部首＝$_" } $notes_by_prefix->('b');
            push @code_source_notes, map { "読み＝$_" } $notes_by_prefix->('y');

            next if !@hb_keys && !@hy_keys;
            my $code_help = "$key => $value";
            if (@code_source_notes) {
                my $joined_notes = join q{、}, @code_source_notes;
                $code_help .= " ($joined_notes)";
            }

            my $b_key = substr $key, 0, 1;
            my $y_key = substr $key, 1, 1;
            for my $b ($b_key, @hb_keys) {
                for my $y ($y_key, @hy_keys) {
                    next if $b eq $b_key && $y eq $y_key;

                    my $array = $suggestions{"$b$y"} //= [];
                    push @$array, $code_help;
                }
            }
        }
    }

    # コードファイルに入っていないのに、常用されている漢字があれば、コード
    # ファイルを直す必要がある。コードを割り当てよう。
    my %code_by_kanji = reverse %codes;
    my @missing;
    for my $ji (keys %kanji_to_priority) {
        if (not defined $code_by_kanji{$ji}) {
            push @missing, $ji;
        }
    }
    if (@missing) {
        print join(q{}, @missing) . "\n";
        die 'Characters missing from code file.';
    }

    if ($stats_mode) {
        my $total_unassigned = 0;
        for my $level (reverse sort keys %unassigned_by_priority) {
            my $dim = 2;
            my $array = $unassigned_by_priority{$level};
            my $u = @$array;
            my $a = keys($ji_set_by_priority{$level}) - $u;
            printf "pri %d - %d assigned (%.2f%%), %d unassigned, %d total:\n",
                $level, $a, $a / ($a + $u) * 100, $u, $a + $u;

            while ($dim * $dim * 3 < @$array * 4) {
                $dim++;
            }
            my @img;
            for (my $i = 0; $i < ($dim * $dim); $i++) {
                push @img, q{　};
            }
            $total_unassigned += @$array;
            for my $kanji (sort @$array) {
                my $hash = ord($kanji);
                my $x = 0;
                my $y = 0;
                for (my $i = 0; $i < 7; $i++) {
                    $y <<= 1;
                    $y |= $hash & 1;
                    $hash >>= 1;
                    $x <<= 1;
                    $x |= $hash & 1;
                    $hash >>= 1;
                }
                $x *= ($dim - 1);
                $y *= ($dim - 1);
                {
                    use integer;
                    $x /= 127;
                    $y /= 127;
                }
                while ($img[$x + ($y * $dim)] ne q{　}) {
                    if ($y & 1) {
                        if (--$x < 0) {
                            $x = 0;
                            $y++;
                        }
                    } elsif (++$x >= $dim) {
                        $x = $dim - 1;
                        $y++;
                    }
                    if ($y >= $dim) {
                        $y = 0;
                        $x = 0;
                    }
                }
                $img[$x + ($y * $dim)] = $kanji;
            }
            for (my $y = 0; $y < $dim; $y++) {
                for (my $x = 0; $x < $dim; $x++) {
                    print $img[$x + ($y * $dim)];
                }
                print "\n";
            }
            print "\n";
        }
        print "合計漢字数\n";
        print "unassigned: $total_unassigned\n";
        printf "assigned: $total_assigned (%.1f%%)\n",
            ($total_assigned * 100 / ($total_assigned + $total_unassigned));

        # 部首＋読みの750個の組み合わせそれぞれに該当する漢字数を計算する
        my %lcase_count;
        my %ucase_count;
        my @prefixes;
        for my $first_key (@kanji_keys) {
            for my $second_key (@kanji_keys) {
                next if $second_key =~ m/[aiueo]/;
                my $prefix = "$first_key$second_key";
                my $lcase_occupied_count = 0;
                my $ucase_occupied_count = 0;
                for my $third_key (@kanji_keys) {
                    my $lcase_code = $prefix . $third_key;
                    my $ucase_code = shift_last_char($lcase_code);
                    my $ucase_kanji = $codes{$ucase_code};
                    my $ucase_pri = defined $ucase_kanji
                        ? read_priority($ucase_kanji)
                        : -1;
                    if ($ucase_pri >= $max_pri - 1) {
                        print "$ucase_code\t$ucase_kanji # 優先度=$ucase_pri\n";
                    }
                    if (defined $codes{$lcase_code}) {
                        $lcase_occupied_count++;
                        if (defined $codes{$ucase_code}) {
                            $ucase_occupied_count++;
                        }
                    } elsif (defined $ucase_kanji) {
                        print "${lcase_code}に該当する漢字がないのに、";
                        print "${ucase_code}に「$codes{$ucase_code}」が";
                        print "割り当てられている。\n";
                    }
                }
                $lcase_count{$prefix} = $lcase_occupied_count;
                $ucase_count{$prefix} = $ucase_occupied_count;
                push @prefixes, $prefix;
            }
        }
        @prefixes = sort { $lcase_count{$b} <=> $lcase_count{$a} } @prefixes;
        printf "\nprefix code# codE#\n";
        for my $prefix (@prefixes) {
            my $lcase= $lcase_count{$prefix} // 0;
            my $ucase= $ucase_count{$prefix} // 0;
            printf "%s     %5d %5d\n", $prefix, $lcase, $ucase;
        }
        print "\n";
        exit 0;
    }

    for my $key (keys %codes) {
        next if $key !~ m/^(.)i$/;
        my $first_key = $1;
        my $first_kana = $codes{$key};
        # TODO: 日本キーボード配列に対応させる
        my %number_substs = qw{
            7 ゃ
            & ゃう
            8 ゅ
            * ゅう
            9 ょ
            ( ょう
        };
        while (my ($number, $kana) = each %number_substs) {
            my $new_key = $first_key . $number;
            write_code($new_key, $codes{$key} . $kana);
        }
    }

    # ２文字コードの前に数字を入れてかなを効率良く入力できるようにする
    for my $key (keys %codes) {
        next if length($key) != 2;
        my %number_substs = qw(
            1 っ
            2 い
            3 あ
            4 う
            5 え
            6 お
            0 ん
        );
        while (my ($number, $kana) = each %number_substs) {
            my $new_key = $number . $key;
            $new_key =~ s/;//;
            write_code($new_key, $kana . $codes{$key});
        }
    }

    # カタカナのコードをひらがなのコードから自動生成する
    # 尚、CAPSLOCKがオンでも一般の漢字を入力できるようにする
    for my $key (keys %codes) {
        my $ukey = $key;
        $ukey =~ tr/a-zA-Z/A-Za-z/;
        my $uvalue = $codes{$key};
        $uvalue =~ tr/ぁ-ゖ/ァ-ヶ/;
        write_code($ukey, $uvalue);
    }
}
read_codes;

ReadMode 4; # Turn off controls keys

my @input_history;

sub print_keyboard_row {
    my ($left_padding, $key_names, $keyboard_ref) = @_;
    my @key_name_array = split q{}, $key_names;

    my $draw_frame = !$keyboard_ref;
    $keyboard_ref //= {};

    if ($draw_frame) {
        print $left_padding;
        my $separator = q{};
        for my $key_name (@key_name_array) {
            if ($key_name eq q{ }) {
                print q{  };
                next;
            }
            printf '%s┌%s ┐', $separator, $key_name;
            $separator = q{ };
        }
        erase_to_eol;
    }
    print "\n";
    print $left_padding;
    for my $key_name (@key_name_array) {
        if ($key_name eq q{ }) {
            print q{  };
            next;
        }
        my $key_value = $keyboard_ref->{$key_name} || q{  };
        my $shift_value = $keyboard_ref->{shift_last_char $key_name} || q{│ };
        if ($shift_value eq $key_value) {
            $shift_value = '々';
        }
        if (char_width($key_value) > 2) {
            $key_value = q{..};
        }
        if (char_width($shift_value) > 2) {
            $shift_value = q{..};
        }
        printf '│%s%s', $key_value, $shift_value;
    }
    erase_to_eol;
    print "\n";
    if ($draw_frame) {
        print $left_padding;
        my $separator = q{};
        for my $key_name (@key_name_array) {
            if ($key_name eq q{ }) {
                print q{  };
                next;
            }
            my $index_finger_key = $key_name eq 'f' || $key_name eq 'j';
            printf '%s└%s┘', $separator, ($index_finger_key ? '==' : '──');
            $separator = q{ };
        }
        erase_to_eol;
    }
}

# The argument is a hash from keys (e.g. 'f') to something to draw inside the
# keyboard in the guide. If the key is omitted in the map, the key is kept
# blank. Otherwise, it should be a single wide character.
# If that argument is omitted, then it only draws the keyboard outline.
sub print_keyboard {
    my ($keyboard_ref) = @_;

    my ($width, $height) = GetTerminalSize;
    printf "\033[%d;0H", ($height - 8);

    print_keyboard_row q{}, 'qwert yuiop', $keyboard_ref;
    print "\n";
    print_keyboard_row q{  }, 'asdfg hjkl;', $keyboard_ref;
    print "\n";
    print_keyboard_row q{    }, 'zxcvb nm,./', $keyboard_ref;
}

my $last_term_size = q{};
sub maybe_refresh_screen {
    my $term_size = join q{,}, GetTerminalSize;
    return if $term_size eq $last_term_size;
    $last_term_size = $term_size;

    clear_screen;

    printf "\033[0;0H";
    for my $past_input (@input_history) {
        print "$past_input\n";
    }

    print_keyboard;
}

# 標準入力からキーを一つ読むか、Alt+キーを読む
sub read_key_chord {
    my @keys;
    push @keys, ReadKey(0);
    if (ord($keys[0]) == 033) {
        push @keys, ReadKey(0);
        if ($keys[1] eq 'O') {
            # 矢印キーを押している。
            push @keys, ReadKey(0);
        }
    }
    return join(q{}, @keys);
}

# 一文字の漢字入力キーとしての値をずらす。
# 英字以外の値はキーボード上の並べ方で決まっている。
# aAbBcCdD...が０～５１
# 【;:,<.>/?】が５２～５９
# $changeが加減する数
# $charがずらされる文字への参照
sub increment_key {
    my ($char, $change) = @_;
    my $value;
    if ($$char =~ m/[a-z]/) {
        $value = (ord($$char) - ord('a')) * 2;
    } elsif ($$char =~ m/[A-Z]/) {
        $value = (ord($$char) - ord('A')) * 2 + 1;
    } else {
        $$char =~ tr#;:,<.>/?#abcdefgh#;
        $value = (ord($$char) - ord('a')) + 52;
    }
    $value += $change;
    $value %= 60;
    if ($value >= 52) {
        $$char = chr(ord('a') + $value - 52);
        $$char =~ tr#abcdefgh#;:,<.>/?#;
    } elsif ($value & 1) {
        $$char = chr(ord('A') + ($value - 1) / 2);
    } else {
        $$char = chr(ord('a') + $value / 2);
    }
    return $$char;
}

while (1) {
    local $";
    $" = q{};

    maybe_refresh_screen;

    # Jump to underneath the last input history item
    printf "\033[%d;0H", scalar(@input_history) + 1;

    print "@entered_text";
    if (@uncommitted) {
        print "<@uncommitted>";
    }

    erase_to_eol;

    my $key = read_key_chord;
    if ($key eq "\eh") {
        my $prefix = join q{}, @uncommitted;
        print "\n";
        my $suggestions = $suggestions{$prefix} // [];
        for my $suggestion (@$suggestions) {
            print "$suggestion\n";
        }
        read_key_chord;
        next;
    } elsif ($key eq "\eb") {
        print <<"BUSHU_CHART";

鍵  部首
---------------------------------------------------
a   一 丨 丶 丿 乙 亅  【二画】二 亠
b   人
c   儿 入 八 冂 冖 冫 几 凵 刀 力 勹 匕 匚 匸 十 卜
d   卩 厂 厶 又  【三画】口 ツ
e   囗 土 士 夂 夊 夕 大
f   女 子 宀 寸 小 尢
g   尸 屮 山 巛 工 己 巾 干 幺 广 廴 廾
h   弋 弓 彐 彡 彳  【四画】心
i   戈 戶 手
j   支 攴 文 斗 斤 方 无 日 曰 月
k   木
l   欠 止 歹 殳 毋 比 毛 氏 气
m   水
n   火 爪 父 爻 爿 片 牙 牛 犬【五画】玄
o   玉 瓜 瓦 甘 生 用 田 疋 疒
p   癶 白 皮 皿 目 矛 矢 石
q   示 禸 禾 穴 立
r   竹  【六画】米
s   糸 缶 网 羊
t   羽 老 而 耒 耳 聿 肉 臣 自 至 臼 舌 舛 舟
u   艮 色 艸
v   虍 虫 血 行 衣
w   襾  【七画】見 角 言 谷 豆 豕
x   豸 貝 赤 走 足 身 車
y   辛 辰 辵 邑 酉 釆 里
z 【八画】金
;   長 門 阜 隶 隹 雨 靑 非【九画】面 革 韋 韭 音
,   頁 風 飛 食 首 香【十画】馬 骨 高 髟 鬥
.   鬯 鬲 鬼 【十一画】魚 鳥 鹵
/   鹿 麥 麻 黃【十二画以上】黍 黑 黹 黽 鼎 鼓 鼠
    鼻 齊 齒 龍 龜 龠
BUSHU_CHART
        read_key_chord;
        next;
    } elsif ($key eq "\eq") {
        last;
    } elsif ($key =~ m#\033O([ABCD])#) {
        # 矢印キーを押した。未確定文字をずらす。
        # 左右で一文字目、上下で二文字目を変える。
        my $dir = $1;
        my $index = ($dir =~ m/[AB]/ ? 1 : 0);
        next if $index >= @uncommitted;
        my $change = ($dir =~ m/[BC]/) ? 1 : -1;
        my $joined;
        my $tries_left = 60;
        do {
            increment_key(\$uncommitted[$index], $change);
            $joined = join(q{}, @uncommitted);
            last if !--$tries_left;
        } while (defined($codes{$joined}) || !defined($code_prefixes{$joined}));
    } elsif (length($key) > 1) {
        next;
    } elsif (ord($key) < 0x20 && $key ne "\n") {
        next;
    } elsif ($key eq "\n") {
        if (@uncommitted) {
            push @entered_text, @uncommitted;
            @uncommitted = ();
        } elsif (!@entered_text) {
            @input_history = ();
            # 開発中はコードを調整・追加するので、コードを最読込
            read_codes;

            # 乱れている場合があるので、キーボードを最描画する
            clear_screen;
            print_keyboard;
        } else {
            my $completed_text = join q{}, @entered_text;
            push @input_history, $completed_text;
            term_copy $completed_text;
            @entered_text = ();
        }
    } elsif (ord($key) == 127) {
        # Backspace
        if (@uncommitted) {
            pop @uncommitted;
        } elsif (@entered_text) {
            pop @entered_text;
        }
    } else {
        push @uncommitted, $key;
    }

    while (@uncommitted > 3) {
        push @entered_text, shift(@uncommitted);
    }

    for (my $i = 0; $i < 2; $i++) {
        my $maybe_code = join q{}, @uncommitted;
        if ($codes{$maybe_code}) {
            push @entered_text, $codes{$maybe_code};

            if (length($maybe_code) == 3) {
                my @chars = split q{}, $maybe_code;
                my %keyboard = (
                    $chars[0] => '1 ',
                    $chars[1] => '2 ',
                    $chars[2] => guide_ji($maybe_code),
                );
                print_keyboard \%keyboard;
            }
            @uncommitted = ();
        }

        while (@uncommitted >= 3) {
            push @entered_text, shift(@uncommitted);
        }
    }

    my %keyboard = ();
    for my $key (@kanji_keys, map {shift_last_char $_} @kanji_keys) {
        my $suggested_code = join q{}, @uncommitted, $key;
        if ($codes{$suggested_code}) {
            $keyboard{$key} = guide_ji $suggested_code;
        }
    }
    if (%keyboard) {
        print_keyboard \%keyboard;
    }
}

ReadMode 1;
